// Prisma Schema f√ºr NerdQuiz
// Dokumentation: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  // URL wird in prisma.config.ts konfiguriert (Prisma 7+)
}

// ============================================
// QUIZ & FRAGEN (JSONB-basiert f√ºr Flexibilit√§t)
// ============================================

model Category {
  id          String     @id @default(cuid())
  slug        String     @unique // "gaming", "filme_serien", "wissenschaft"
  name        String     // "Gaming", "Filme & Serien"
  description String?
  icon        String     // Emoji: "üéÆ", "üé¨"
  color       String?    // Hex-Farbe f√ºr UI: "#6366f1"
  sortOrder   Int        @default(0) // F√ºr manuelle Sortierung
  isActive    Boolean    @default(true) // Kategorie aktivieren/deaktivieren
  
  questions   Question[]
  
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@index([isActive])
  @@map("categories")
}

model Question {
  id           String       @id @default(cuid())
  categoryId   String
  category     Category     @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  
  // Basis-Felder
  text         String       // Die Frage selbst
  type         QuestionType @default(MULTIPLE_CHOICE)
  difficulty   Difficulty   @default(MEDIUM)
  
  // JSONB Content - Struktur abh√§ngig vom Type
  // MULTIPLE_CHOICE: { correctAnswer: string, incorrectAnswers: string[] }
  // ESTIMATION: { correctValue: number, unit: string, tolerance?: number }
  // TRUE_FALSE: { correctAnswer: boolean }
  // SORTING: { items: string[], labels?: { top: string, bottom: string } }
  // TEXT_INPUT: { acceptedAnswers: string[], caseSensitive?: boolean }
  // MATCHING: { pairs: { clue: string, match: string }[] }
  // COLLECTIVE_LIST: { topic: string, items: { id: string, display: string, aliases: string[] }[], timePerTurn?: number, fuzzyThreshold?: number }
  content      Json
  
  // Medien-Support
  mediaType    MediaType    @default(NONE)
  mediaUrl     String?      // URL zu Supabase Storage oder extern
  
  // Metadaten
  explanation  String?      // Optionale Erkl√§rung nach Beantwortung
  source       String?      // "manual", "opentdb", "community"
  externalId   String?      // ID aus externen Quellen (OpenTDB)
  
  // Statistiken
  timesPlayed  Int          @default(0)
  timesCorrect Int          @default(0)
  
  // Status
  isVerified   Boolean      @default(false) // Von Admin gepr√ºft
  isActive     Boolean      @default(true)  // Frage aktivieren/deaktivieren
  
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  @@unique([source, externalId]) // Verhindert Duplikate bei Imports
  @@index([categoryId])
  @@index([type])
  @@index([difficulty])
  @@index([isActive])
  @@map("questions")
}

enum QuestionType {
  MULTIPLE_CHOICE  // Standard: 4 Antworten, eine richtig
  ESTIMATION       // Sch√§tzfrage mit Zahlenwert
  TRUE_FALSE       // Wahr/Falsch (OpenTDB boolean)
  SORTING          // Elemente in richtige Reihenfolge bringen
  TEXT_INPUT       // Freitext-Eingabe (f√ºr Bildr√§tsel)
  MATCHING         // Zuordnungsfrage (Zitat ‚Üí Person)
  COLLECTIVE_LIST  // Bonusrunde: Spieler nennen nacheinander Items aus einer Liste
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
}

enum MediaType {
  NONE
  IMAGE
  AUDIO
  VIDEO
}

// ============================================
// SPIEL-HISTORIE (Cold Data)
// ============================================

model GameSession {
  id           String       @id @default(cuid())
  roomCode     String       // 4-stelliger Raum-Code
  
  // Spielkonfiguration
  maxRounds    Int
  questionsPerRound Int
  
  // Spielstatus
  status       GameStatus   @default(COMPLETED)
  totalRounds  Int
  
  // Zeitstempel
  startedAt    DateTime
  endedAt      DateTime?
  
  // Spieler-Ergebnisse
  results      PlayerResult[]
  
  createdAt    DateTime     @default(now())

  @@index([roomCode])
  @@index([createdAt])
  @@map("game_sessions")
}

model PlayerResult {
  id            String      @id @default(cuid())
  gameSessionId String
  gameSession   GameSession @relation(fields: [gameSessionId], references: [id], onDelete: Cascade)
  
  playerName    String
  finalScore    Int
  correctAnswers Int
  totalAnswers  Int
  rank          Int         // Platzierung im Spiel
  
  createdAt     DateTime    @default(now())

  @@index([gameSessionId])
  @@map("player_results")
}

enum GameStatus {
  IN_PROGRESS
  COMPLETED
  ABANDONED
}

// ============================================
// ADMIN & USER
// ============================================

model User {
  id           String   @id @default(cuid())
  username     String   @unique
  displayName  String
  avatarSeed   String?  // F√ºr DiceBear Avatare
  role         UserRole @default(PLAYER)
  
  // Statistiken
  gamesPlayed  Int      @default(0)
  gamesWon     Int      @default(0)
  totalScore   Int      @default(0)
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("users")
}

enum UserRole {
  PLAYER
  MODERATOR
  ADMIN
}

// ============================================
// IMPORT-TRACKING
// ============================================

model ImportLog {
  id           String   @id @default(cuid())
  source       String   // "opentdb", "json_migration"
  filename     String?  // Originaldatei
  
  questionsAdded   Int
  questionsSkipped Int  // Duplikate
  questionsFailed  Int  // Fehlerhafte
  
  details      Json?    // Zus√§tzliche Infos
  
  createdAt    DateTime @default(now())

  @@map("import_logs")
}
